/-
Copyright (c) 2023 Michael Stoll. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Michael Stoll
-/

import combinatorics.rado.rank_function_independent_global

/-!
# Rado's Theorem

We prove a version of **Rado's Theorem** in terms of a *rank function*.
A rank function is a function from finite sets of a type `α` to the natural
numbers that has properties similar to the dimension of the linear subspace
generated by a finite subset of a vector space. We say that a function
`f : ι → α` is *independent* (with respect to `r`) if for every finite subset `s`
of `ι`, the rank of the image of `s` under `f` is (at least) the cardinality of `s`.

If we have a family `F : ι → finset α` of finite subsets of `α`, then we say
that a function `f : ι → α` is a *section* of `F` if `f i ∈ F i` for all `i : ι`.

We fix a rank function `r` on a type `α` and a family `F : ι → finset α`
of finite subsets of `α`. Then Rado's Theorem says that there exists an independent
(w.r.t. `r`) section of `F` if and only if `r` and `F` satisfy the "Rado condition"
that for each finite subset `s` of `ι`, the rank of `⋃ i in s, F i` is at least
the cardinality of `s`.

If we specialize this to the rank function given by the cardinality of a set,
we obtain *Hall's Theorem*. Specializing to the dimension of the generated
submodule (where `α` is a vector space), we obtain a statement that gives
us a linearly independent section of `F` (under the obvious necessary condition).

## Implementation Notes

We first prove a more general statement, where we consider an additional
finite subset `t` of `α` such that `r t = #t` and ask that `r (f '' s ∪ t) = #s + #t`.
This version can be proved by induction on `s` (with varying `t`). We then
obtain (the interesting direction of) Rado's theorem by specializing `t` to be the empty set.
-/

namespace rank_fn

open finset

universes u v

variables {ι : Type u} {α : Type v} [decidable_eq α]

/-!
### The Rado condition

Given a rank funciton `r` on `α`, a family `F : ι → finset α`, and a finset `s` of `ι`,
we say that *`F` satisfies the Rado condition on `s`* if the rank of the union of `F i`
over all `i ∈ t` is at least the cardinality of `t`, for all subsets `t ⊆ s`.

We say that *`F` satisfies the Rado condition* if it satisfies the Rado condition
on every finset `s` of `ι`.

We define these notions (see `rank_fn.rado_cond_on` and `rank_fn.rado_cond`) and
a relative version of `rank_fn.rado_cond_on`, where a function `f` that is an
independent section on a disjoint subset `s'` is fixed and we ask that the rank of
`(f '' s') ∪ ⋃ i in t, F i` is at least the sum of the cardinalties of `s'` and of `t`
(see `rank_fn.rado_cond_on'`).

We then prove some properties that will be used in the proof of Rado's Theorem.
-/

/-- A family `F : ι → finset α` satisfies the Rado condition with respect to the rank
function `r` if for each finset `s` of `ι`, the rank of `⋃ i in s, F i` is at least
the cardinality of `s`. -/
def rado_cond (r : rank_fn α) (F : ι → finset α) : Prop :=
∀ s : finset ι, s.card ≤ r (s.bUnion F)

/- Everything below except `rank_fn.rado` could be marked as `private`, since
   it is only used in the proof and unlikely to be useful outside of that.
-/

/-- A family `F : ι → finset α` satisfies the Rado condition with respect to the rank
function `r` on `s` if for subsets `t ⊆ s`, the rank of `⋃ i in t, F i` is at least
the cardinality of `t`. -/
def rado_cond_on (r : rank_fn α) (F : ι → finset α) (s : finset ι) : Prop :=
∀ ⦃t : finset ι⦄, t ⊆ s → t.card ≤ r (t.bUnion F)

/-- A family `F : ι → finset α` and a function `f : ι → α` satisfy the Rado condition
on finite subsets `s'` and `s` of `ι` if `s'` and `s` are disjoint, `f` is an independent
section on `s'`, and for each subset `t ⊆ s`, the rank of `(f '' s') ∪ ⋃ i in t, F t` is
at least the sum of the cardinalities of `s'` and of `t`. -/
def rado_cond_on' (r : rank_fn α) (F : ι → finset α) (f : ι → α) (s' s : finset ι) : Prop :=
disjoint s' s ∧ (∀ ⦃i⦄, i ∈ s' → f i ∈ F i) ∧ independent_on r f s' ∧
  ∀ ⦃t : finset ι⦄, t ⊆ s → s'.card + t.card ≤ r (s'.image f ∪ t.bUnion F)

lemma rado_cond_on'.congr {r : rank_fn α} {F : ι → finset α} {f g : ι → α} {s' s : finset ι}
  (hf : rado_cond_on' r F f s' s) (h : set.eq_on f g ↑s') :
  rado_cond_on' r F g s' s :=
begin
  obtain ⟨hf₁, hf₂, hf₃, hf₄⟩ := hf,
  refine ⟨hf₁, λ i hi, h hi ▸ hf₂ hi, hf₃.congr h, λ t ht, (hf₄ ht).trans_eq _⟩,
  congr' 2,
  exact image_congr h,
end

/-- The strong Rado condition for `F` and `f`, `s'` and `s`. It requires that
for nonempty proper subsets `t` of `s`, the rank inequality is strict. -/
def rado_cond_on'_strong (r : rank_fn α) (F : ι → finset α) (f : ι → α) (s' s : finset ι) :
  Prop :=
disjoint s' s ∧ (∀ ⦃i⦄, i ∈ s' → f i ∈ F i) ∧ independent_on r f s' ∧
  s'.card + s.card ≤ r (s'.image f ∪ s.bUnion F) ∧
  ∀ ⦃t : finset ι⦄, t ⊂ s → t.nonempty → s'.card + t.card < r (s'.image f ∪ t.bUnion F)

lemma rado_cond_on'_strong.congr {r : rank_fn α} {F : ι → finset α} {f g : ι → α}
  {s s' : finset ι} (hf : rado_cond_on'_strong r F f s' s) (h : set.eq_on f g ↑s') :
  rado_cond_on'_strong r F g s' s :=
begin
  obtain ⟨hf₁, hf₂, hf₃, hf₄, hf₅⟩ := hf,
  refine ⟨hf₁, λ i hi, h hi ▸ hf₂ hi, hf₃.congr h, hf₄.trans_eq _, λ t ht ht',
          (hf₅ ht ht').trans_eq _⟩;
    { congr' 2, exact image_congr h, },
end

/-- If the Rado condition holds on `s`, then it also holds for each subset of `s`. -/
lemma rado_cond_on'.subset {r : rank_fn α} {F : ι → finset α} {f : ι → α}
  {s' t s : finset ι} (h : rado_cond_on' r F f s' s) (hts : t ⊆ s) :
  rado_cond_on' r F f s' t :=
⟨disjoint_of_subset_right hts h.1, h.2.1, h.2.2.1, λ t' ht', h.2.2.2 $ ht'.trans hts⟩

/-- If the strong Rado condition holds for `(f, s', insert i s)` (and `i ∉ s' ∪ s`)
and `f` is a section and independent on `insert i s'`, then the Rado condition holds
for `(f, insert i s', s)`. -/
lemma rado_cond_on'.prop₁ [decidable_eq ι] {r : rank_fn α} {F : ι → finset α} {f : ι → α}
  {s' s : finset ι} {i : ι} (hi : i ∉ s' ∪ s) (h : rado_cond_on'_strong r F f s' (insert i s))
  (h'₁ : ∀ ⦃j⦄, j ∈ insert i s' →  f j ∈ F j) (h'₂ : independent_on r f (insert i s')) :
  rado_cond_on' r F f (insert i s') s :=
begin
  obtain ⟨his', his⟩ := not_mem_union.mp hi,
  refine ⟨disjoint_insert_left.mpr ⟨his, (disjoint_insert_right.mp h.1).2⟩,
          h'₁, h'₂, λ t ht, _⟩,
  simp only [card_insert_eq_ite, his', if_false, image_insert, insert_union],
  rw [← union_insert, add_assoc, add_comm 1, ← add_assoc],
  rcases eq_empty_or_nonempty t with rfl | ht₁,
  { convert h'₂,
    { simp only [his', card_empty, add_zero, card_insert_of_not_mem, not_false_iff], },
    { simp only [insert_eq, image_union, bUnion_empty, union_empty, image_singleton],
      exact union_comm _ _, } },
  { refine (nat.lt_iff_add_one_le.mp (h.2.2.2.2 (finset.ssubset_of_subset_of_ssubset ht $
             ssubset_insert his) ht₁)).trans _,
    rw [union_insert],
    exact r.le_insert _ _, }
end

/-- If the Rado condition holds for `(f, s', s)`, `t` is a subset of `s` such that
we have equality in the Rado rank condition for `t`, and `f` is a section and independent
on `s' ∪ t`, then the Rado condition also holds for `(f, s' ∪ t, s \ t)`. -/
lemma rado_cond_on'.prop₂ [decidable_eq ι] {r : rank_fn α} {F : ι → finset α} {f : ι → α}
  {s' s t : finset ι} (ht₁ : t ⊆ s) (h : rado_cond_on' r F f s' s)
  (h'₁ : ∀ ⦃i⦄, i ∈ s' ∪ t → f i ∈ F i) (h'₂ : independent_on r f (s' ∪ t))
  (ht₂ : s'.card + t.card = r (s'.image f ∪ t.bUnion F)) :
  rado_cond_on' r F f (s' ∪ t) (s \ t) :=
begin
  obtain ⟨h₁, _, _, h₄⟩ := h,
  have ht₃ := (disjoint_of_subset_left ht₁ h₁.symm).symm,
  refine ⟨disjoint_union_left.mpr ⟨disjoint_of_subset_right (sdiff_subset s t) h₁, disjoint_sdiff⟩,
          h'₁, h'₂, λ t' ht', _⟩,
  rw [← card_union_eq ht₃] at ht₂,
  have H : image f (s' ∪ t) ⊆ image f s' ∪ t.bUnion F,
  { rw [image_union],
    exact union_subset_union subset_rfl
      (image_subset_iff.mpr $ λ i hi, mem_bUnion.mpr ⟨i, hi, h'₁ (mem_union_right  _ hi)⟩), },
  rw [r.stationary (t'.bUnion F) H (le_antisymm (r.mono H) (ht₂.symm.trans_le h'₂))],
  convert h₄ (union_subset ht₁ $ ht'.trans $ sdiff_subset _ _) using 1,
  { rw [card_union_eq ht₃, card_union_eq (disjoint_of_subset_left ht' sdiff_disjoint).symm,
        add_assoc], },
  { rw [bUnion_union, union_assoc], }
end

/-!
### Proof of Rado's Theorem

The idea of the proof is as follows. We are given a family `F : ι → finset α` that satisfies
the Rado condition with respect to a rank fuction `r`. We want to show that for each
finite subset `s` of `ι` there is a function `f : ι → α` that has the Rado property.

We do this by proving the following more general statement.

*If `rado_cond_on' r F f s' s` holds, then there is `g : ι → α` such that `g = f` on `s'`
and `g` is an independent section on `s' ∪ s`.*

The proof of the existence of independent sections on every finite subset `s` is then
  "`rado_cond r F` ⇒ `rado_cond_on' r F _ ∅ s` ⇒ `∃ f, independent_on r F f s`".

We then use this as input to the compactness argument to obtain the existence
of an independent section on `ι`.

The converse, that the existence of an independent section implies the Rado condition,
is quite straight-forward.
-/

variables {r : rank_fn α} {F : ι → finset α}

/-- Auxiliary statment for Rado's Theorem. -/
lemma rado_aux [decidable_eq ι] {f : ι → α} {s' s : finset ι} (h : rado_cond_on' r F f s' s) :
  ∃ g : ι → α, set.eq_on g f ↑s' ∧ independent_on r g (s' ∪ s) ∧ ∀ ⦃i⦄, i ∈ s' ∪ s → g i ∈ F i :=
begin
  revert f s',
  refine finset.strong_induction_on s (λ s ih f s' hr, _),
  rcases eq_empty_or_nonempty s with rfl | hs,
  { -- case `s = ∅`
    exact ⟨f, λ _ _, rfl, by {rw union_empty, exact ⟨hr.2.2.1, hr.2.1⟩}⟩, },
  by_cases H : rado_cond_on'_strong r F f s' s,
  { -- all nonempty proper subsets satisfy the strict rank inequality
    have H' := H,
    obtain ⟨H₁, H₂, H₃, _⟩ := H',
    obtain ⟨i, hi⟩ := nonempty.bex hs,
    have hi₁ : i ∉ s' ∪ s.erase i :=
      not_mem_union.mpr ⟨disjoint_right.mp H₁ hi, not_mem_erase i s⟩,
    obtain ⟨g, hg₁, hg₂, hg₃⟩ := H₃.extends (disjoint_right.mp H₁ hi) H₂ _,
    { rw ← insert_erase hi at H,
      -- use `rado_cond_on'.prop₁` and the inductive hypothesis
      obtain ⟨f₁, hf₁, hf₂⟩ :=
        ih (s.erase i) (erase_ssubset hi)
           (rado_cond_on'.prop₁ hi₁ (H.congr hg₁) hg₃ hg₂),
      rw [insert_union, ← union_insert, insert_erase hi] at hf₂,
      exact ⟨f₁, λ j hj, (hf₁ $ mem_insert_of_mem hj).trans (hg₁ hj).symm, hf₂⟩, },
    { exact nat.add_one_le_iff.mp (by simpa only [card_singleton, singleton_bUnion]
                                        using hr.2.2.2 (singleton_subset_iff.mpr hi)), } },
  { -- for some nonempty proper subset `t`, we have equality
    have hr' := hr,
    obtain ⟨hr₁, hr₂, hr₃, hr₄⟩ := hr',
    dsimp only [rado_cond_on'_strong] at H,
    push_neg at H,
    obtain ⟨t, ht₁, ht₂, ht₃⟩ := H hr₁ hr₂ hr₃ (hr₄ subset_rfl),
    -- use the inductive hypothesis for `t`
    obtain ⟨f', hf'₁, hf'₃, hf'₄⟩ := ih t ht₁ (hr.subset ht₁.subset),
    replace ht₃ := le_antisymm (hr₄ ht₁.subset) ht₃,
    have hc : s'.image f = s'.image f' := (image_congr hf'₁).symm,
    -- use `rado_cond_on'.prop₂`
    have hrc := (hr.congr $ λ i hi, (hf'₁ hi).symm).prop₂ ht₁.subset hf'₄ hf'₃ (hc ▸ ht₃),
    -- use the inductive hypothesis again for `s \t`
    obtain ⟨g, hg₁, hg₂⟩ := ih (s \ t) (sdiff_ssubset ht₁.subset ht₂) hrc,
    rw [union_assoc, union_sdiff_self_eq_union, union_eq_right_iff_subset.mpr ht₁.subset] at hg₂,
    exact ⟨g, λ i hi, (hg₁ $ mem_union_left _ hi).trans $ hf'₁ hi, hg₂⟩, }
end

/-- Rado's Theorem for finite families. If `F : ι → finset α` satsifies the Rado condition
with respect to a rank function `r` on `α`, then for each finite subset `s` of `ι` there
is an independent section `f : ι → α` on `s`. Note that `f` here depends on `s`.
We state this here in the form that `rank_fn.independent_sections_on r F s` is nonempty. -/
lemma independent_sections_on.nonempty [nonempty α] {r : rank_fn α} {F : ι → finset α}
  (h : rado_cond r F) (s : finset ι) : nonempty (independent_sections_on r F s) :=
begin
  -- `rado_cond r F` ⇒ `rado_cond_on' r F _ ∅ s` ⇒ `∃ f, independent_on r F f s`
  -- We need `[inhabited α]` to be able to write down some function `ι → α`.
  haveI : inhabited α := classical.inhabited_of_nonempty',
  have h' : rado_cond_on' r F default ∅ s,
  { refine ⟨disjoint_empty_left s,
            λ i hi, false.elim (not_mem_empty i hi), card_empty.trans_le $ zero_le _,
            λ t ht, _⟩,
    rw [card_empty, zero_add, image_empty, empty_union],
    exact h t, },
  classical,
  obtain ⟨f, _, hf₁, hf₂⟩ := rado_aux h',
  rw empty_union at hf₁ hf₂,
  exact ⟨classical.indefinite_description _
          ⟨set.restrict ↑s f,
           independent_on_iff_independent_restrict.mp hf₁,
           λ i hi, by simpa only [set.restrict_apply, subtype.coe_mk] using hf₂ hi ⟩⟩,
end

variables {r F}

/-- Auxiliary lemma that deals with the case when `α` is an empty type. In this case,
the indexing type `ι` must also be empty when the Rado condition is satisfied. -/
lemma rado_cond_empty [is_empty α] (h : rado_cond r F) : is_empty ι :=
begin
  refine (is_empty_or_nonempty ι).resolve_right (λ hf, _),
  haveI := classical.inhabited_of_nonempty hf,
  specialize h {default},
  rw [card_singleton, singleton_bUnion, eq_empty_of_is_empty (F default), r.empty] at h,
  exact lt_irrefl _ (h.trans_lt zero_lt_one),
end

/-- **Rado's Theorem** for arbitrary families of finite sets: the family `F : ι → finset α`
satsifies the Rado condition with respect to a rank function `r` on `α` if and only if there
is a function `f : ι → α` that is an independent (w.r.t. `r`) section of `F`. -/
theorem rado : rado_cond r F ↔ ∃ f : ι → α, independent r f ∧ ∀ i, f i ∈ F i :=
begin
  refine ⟨λ h, _, λ h s, _⟩,
  { cases is_empty_or_nonempty α with hα hα,
    { haveI := hα,
      haveI hι := rado_cond_empty h,
      refine ⟨hι.elim, λ s, _, λ i, false.elim (is_empty_iff.mp hι i)⟩,
      { rw [independent_on_def, eq_empty_of_is_empty s, card_empty],
        exact nat.zero_le _, } },
    { haveI := classical.inhabited_of_nonempty hα,
      exact independent.section _ _ (independent_sections_on.nonempty h), } },
  { obtain ⟨f, hf₁, hf₂⟩ := h,
    refine le_trans (hf₁ s) (r.mono $ λ i hi, finset.mem_bUnion.mpr _),
    obtain ⟨j, hj, rfl⟩ := finset.mem_image.mp hi,
    exact ⟨j, hj, hf₂ j⟩, }
end

end rank_fn

section marriage

/-!
### Hall's Theorem as a special case of Rado's Theorem

TODO: Refactor `combinatorics.hall.finite` and `combinatorics.hall.basic`
using Rado's Theorem.
-/

namespace finset

open rank_fn

-- compare finset.all_card_le_bUnion_card_iff_exists_injective

/-- **Halls' Theorem** ("*Marriage Theorem*") -/
theorem marriage {ι : Type*} {α : Type*} [decidable_eq α] {F : ι → finset α} :
  (∀ s : finset ι, (s.card ≤ (s.bUnion F).card)) ↔
    ∃ f : ι → α,  function.injective f ∧ ∀ i, f i ∈ F i :=
begin
  classical,
  simp_rw [← card_rk_eq_card (finset.bUnion _ F), ← independent_card_iff_injective],
  exact rado,
end

end finset

end marriage
